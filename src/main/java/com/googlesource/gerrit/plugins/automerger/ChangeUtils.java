package com.googlesource.gerrit.plugins.automerger;

import com.google.common.base.Joiner;
import com.google.common.flogger.FluentLogger;
import com.google.gerrit.extensions.api.GerritApi;
import com.google.gerrit.extensions.api.changes.ChangeApi;
import com.google.gerrit.extensions.api.changes.NotifyHandling;
import com.google.gerrit.extensions.api.changes.ReviewInput;
import com.google.gerrit.extensions.client.ListChangesOption;
import com.google.gerrit.extensions.common.ChangeInfo;
import com.google.gerrit.extensions.common.CommitInfo;
import com.google.gerrit.extensions.common.RevisionInfo;
import com.google.gerrit.extensions.restapi.AuthException;
import com.google.gerrit.extensions.restapi.RestApiException;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.List;
import java.util.Map;

/** ChangeUtils is a utility class for interacting with Gerrit changes */
public final class ChangeUtils {

  private static final FluentLogger logger = FluentLogger.forEnclosingClass();
  public static final String AUTOMERGER_TAG = "autogenerated:Automerger";
  private static final String SKIPPED_PREFIX = "skipped";
  private static final String CURRENT = "current";

  private ChangeUtils(){
    throw new UnsupportedOperationException("ChangeUtils should not be instantiated.");
  }

  public static QueryBuilder constructTopicQuery(String topic) throws InvalidQueryParameterException {
    QueryBuilder queryBuilder = new QueryBuilder();
    queryBuilder.addParameter("topic", topic);
    queryBuilder.addParameter("status", "open");
    return queryBuilder;
  }

  public static List<ChangeInfo> getChangesInTopicAndBranch(GerritApi gApi, String topic, String downstreamBranch)
      throws InvalidQueryParameterException, RestApiException {
    QueryBuilder queryBuilder = constructTopicQuery(topic);
    queryBuilder.addParameter("branch", downstreamBranch);
    return gApi.changes()
        .query(queryBuilder.get())
        .withOptions(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_COMMIT)
        .get();
  }

  public static List<String> getChangeParents(GerritApi gApi, int changeNumber, String currentRevision)
      throws RestApiException {
    ChangeApi change = gApi.changes().id(changeNumber);
    List<String> parents = new ArrayList<>();
    Map<String, RevisionInfo> revisionMap =
        change.get(EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_COMMIT))
            .revisions;
    List<CommitInfo> changeParents = revisionMap.get(currentRevision).commit.parents;
    for (CommitInfo commit : changeParents) {
      parents.add(commit.commit);
    }
    return parents;
  }

  /**
   * Create subject line for downstream change with metadata from upstream change.
   *
   * <p>The downstream subject will be in the format: "[subjectPrefix] upstreamSubject am:
   * upstreamRevision". If it is a skip, "am" will be replaced with "skipped", and [subjectPrefix]
   * replaced with [subjectPrefix skipped].
   *
   * @param upstreamSubject Subject line of the upstream change
   * @param upstreamRevision Commit SHA1 of the upstream change
   * @param skipped Whether or not the merge is done with "-s ours"
   * @return Subject line for downstream merge
   */
  public static String getSubjectForDownstreamChange(
      String subjectPrefix, String upstreamSubject, String upstreamRevision, boolean skipped) {
    if (!upstreamSubject.startsWith("[" + subjectPrefix)) {
      String prefix = "[" + subjectPrefix + "]";
      if (skipped) {
        prefix = "[" + subjectPrefix + " " + SKIPPED_PREFIX + "]";
      }
      upstreamSubject = Joiner.on(" ").join(prefix, upstreamSubject);
    }
    String denotationString = skipped ? "skipped:" : "am:";
    return Joiner.on(" ")
        .join(upstreamSubject, denotationString, upstreamRevision.substring(0, 10));
  }

  public static String getTopic(GerritApi gApi, String revision) throws InvalidQueryParameterException, RestApiException {
    QueryBuilder queryBuilder = new QueryBuilder();
    queryBuilder.addParameter("commit", revision);
    List<ChangeInfo> changes =
        gApi.changes()
            .query(queryBuilder.get())
            .withOption(ListChangesOption.CURRENT_REVISION)
            .get();
    if (!changes.isEmpty()) {
      for (ChangeInfo change : changes) {
        if (change.currentRevision.equals(revision) && !"".equals(change.topic)) {
          return change.topic;
        }
      }
    }
    return null;
  }

  public static void tagChange(GerritApi gApi, ChangeInfo change, String message) throws RestApiException {
    ReviewInput reviewInput = new ReviewInput();
    reviewInput.message(message);
    reviewInput.notify = NotifyHandling.NONE;
    reviewInput.tag = AUTOMERGER_TAG;
    try {
      gApi.changes().id(change.id).revision(CURRENT).review(reviewInput);
    } catch (AuthException e) {
      logger.atSevere().withCause(e).log("Automerger could not set label, but still continuing.");
    }
  }

  public static String getSkipHashtag(String downstreamBranch){
    return "am_skip_" + downstreamBranch;
  }

  public static boolean isDownstreamCherryPick(GerritApi gApi, String upstreamRevision, ChangeInfo downstreamChange){
    try {
      ChangeInfo upstreamChange = gApi.changes().id(upstreamRevision).get();
      int upstreamPatchset = upstreamChange.revisions.get(upstreamRevision)._number;

      if(downstreamChange.cherryPickOfChange == null)
        return false;

      return downstreamChange.cherryPickOfChange.equals(upstreamChange._number) &&
          downstreamChange.cherryPickOfPatchSet == upstreamPatchset;
    } catch (RestApiException e) {
      logger.atSevere().withCause(e).log(
          "Unable to lookup change with revision %s", upstreamRevision);
      return false;
    }
  }

  public static boolean isDownstreamMerge(String upstreamRevision, ChangeInfo downstreamChange){
    String changeRevision = downstreamChange.currentRevision;
    RevisionInfo revision = downstreamChange.revisions.get(changeRevision);
    List<CommitInfo> parents = revision.commit.parents;
    if (parents.size() > 1) {
      String secondParent = parents.get(1).commit;
      if (secondParent.equals(upstreamRevision)) {
        return true;
      }
    }

    return false;
  }

  public static boolean isDownstreamChange(GerritApi gApi, String upstreamRevision, ChangeInfo downstreamChange, ChangeMode changeMode) {
    boolean downstreamExists = (changeMode == ChangeMode.CHERRY_PICK) && isDownstreamCherryPick(gApi, upstreamRevision, downstreamChange);
    downstreamExists |= (changeMode == ChangeMode.MERGE) && isDownstreamMerge(upstreamRevision, downstreamChange);

    return downstreamExists;
  }

  /**
   * Get the base change ID that the downstream change should be based off of, given the parents.
   *
   * <p>Given changes A and B where A is the first parent of B (stacked changes), and where A' is
   * the downstream change autogenerated by A, and B' is the downstream change autogenerated by A,
   * the first parent of B' should be A'.
   *
   * @param parents Parent commit SHAs of the change
   * @return The base change ID that the change should be based off of, null if there is none.
   * @throws InvalidQueryParameterException
   * @throws RestApiException
   */
  private static ChangeInfo getBaseChangeInfo(GerritApi gApi, List<String> parents, String branch, ChangeMode changeMode)
      throws InvalidQueryParameterException, RestApiException {
    if (parents.isEmpty()) {
      logger.atInfo().log("No base change id for change with no parents.");
      return null;
    }
    // 1) Get topic of first parent
    String firstParentTopic = ChangeUtils.getTopic(gApi, parents.get(0));
    if (firstParentTopic == null) {
      return null;
    }
    // 2) query that topic and use that to find A'
    List<ChangeInfo> changesInTopic = ChangeUtils.getChangesInTopicAndBranch(gApi, firstParentTopic, branch);
    String firstParent = parents.get(0);
    for (ChangeInfo change : changesInTopic) {
      if(isDownstreamChange(gApi, firstParent, change, changeMode)){
        return change;
      }
    }
    return null;
  }
  public static String getBaseChangeIdForMerge(GerritApi gApi, List<String> parents, String branch)
      throws InvalidQueryParameterException, RestApiException {
    ChangeInfo change = getBaseChangeInfo(gApi, parents, branch, ChangeMode.MERGE);

    if(change == null)
      return null;

    return String.valueOf(change._number);
  }

  public static String getBaseChangeRevisionForCherryPick(GerritApi gApi, List<String> parents, String branch)
      throws InvalidQueryParameterException, RestApiException {
    ChangeInfo change = getBaseChangeInfo(gApi, parents, branch, ChangeMode.CHERRY_PICK);

    if(change == null)
      return null;

    return change.currentRevision;
  }

}
