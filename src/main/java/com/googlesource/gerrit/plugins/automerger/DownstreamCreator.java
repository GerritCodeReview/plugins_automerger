// Copyright (C) 2016 The Android Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package com.googlesource.gerrit.plugins.automerger;

import static com.google.common.base.Strings.isNullOrEmpty;

import com.google.common.base.Joiner;
import com.google.common.flogger.FluentLogger;
import com.google.gerrit.entities.Account;
import com.google.gerrit.exceptions.StorageException;
import com.google.gerrit.extensions.api.GerritApi;
import com.google.gerrit.extensions.api.changes.AbandonInput;
import com.google.gerrit.extensions.api.changes.ChangeApi;
import com.google.gerrit.extensions.api.changes.NotifyHandling;
import com.google.gerrit.extensions.api.changes.ReviewInput;
import com.google.gerrit.extensions.client.ListChangesOption;
import com.google.gerrit.extensions.common.ChangeInfo;
import com.google.gerrit.extensions.common.LabelInfo;
import com.google.gerrit.extensions.common.RevisionInfo;
import com.google.gerrit.extensions.events.ChangeAbandonedListener;
import com.google.gerrit.extensions.events.ChangeRestoredListener;
import com.google.gerrit.extensions.events.CommentAddedListener;
import com.google.gerrit.extensions.events.RevisionCreatedListener;
import com.google.gerrit.extensions.events.TopicEditedListener;
import com.google.gerrit.extensions.restapi.AuthException;
import com.google.gerrit.extensions.restapi.MergeConflictException;
import com.google.gerrit.extensions.restapi.RestApiException;
import com.google.gerrit.json.OutputFormat;
import com.google.gerrit.server.CurrentUser;
import com.google.gerrit.server.FanOutExecutor;
import com.google.gerrit.server.submit.IntegrationConflictException;
import com.google.gerrit.server.util.ManualRequestContext;
import com.google.gerrit.server.util.OneOffRequestContext;
import com.google.gson.Gson;
import com.google.inject.Inject;
import com.google.inject.Provider;
import java.io.IOException;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.OptionalInt;
import java.util.Set;
import java.util.TreeMap;
import java.util.UUID;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import org.eclipse.jgit.errors.ConfigInvalidException;

/**
 * DownstreamCreator will receive an event on an uploaded, published, or restored patchset, and
 * upload a merge of the original patchset downstream, as determined by the configuration file. When
 * a topic or vote is changed on a patchset, or a change is abandoned, all downstream patchsets will
 * be modified as well.
 */
public class DownstreamCreator
    implements ChangeAbandonedListener,
        ChangeRestoredListener,
        CommentAddedListener,
        RevisionCreatedListener,
        TopicEditedListener {
  private static final FluentLogger logger = FluentLogger.forEnclosingClass();
  private static final String MERGE_CONFLICT_TAG = "autogenerated:MergeConflict";
  private static final String CURRENT = "current";
  private static final Gson GSON = OutputFormat.JSON_COMPACT.newGson();

  private final GerritApi gApi;
  private final ConfigLoader config;
  private final ExecutorService executorService;
  private final OneOffRequestContext oneOffRequestContext;
  private final Provider<CurrentUser> user;
  private final Provider<ChangeCreatorApi> changeCreator;

  @Inject
  public DownstreamCreator(
      GerritApi gApi,
      ConfigLoader config,
      OneOffRequestContext oneOffRequestContext,
      @FanOutExecutor ExecutorService executorService,
      Provider<CurrentUser> user,
      Provider<ChangeCreatorApi> changeCreator
      ) {
    this.gApi = gApi;
    this.config = config;
    this.oneOffRequestContext = oneOffRequestContext;
    this.executorService = executorService;
    this.user = user;
    this.changeCreator = changeCreator;
  }

  /**
   * Abandons downstream changes if a change is abandoned.
   *
   * @param event Event we are listening to.
   */
  @Override
  public void onChangeAbandoned(ChangeAbandonedListener.Event event) {
    ChangeInfo change = deepCopy(event.getChange());
    CurrentUser user = this.user.get();
    @SuppressWarnings("unused")
    Future<?> ignored =
        executorService.submit(() -> {
          try {
            onChangeAbandonedImpl(change, event.getRevision()._number, config.getContextUserId(user));
          } catch (ConfigInvalidException | UnsupportedOperationException e) {
            logger.atSevere().withCause(e).log(
                "Automerger plugin failed onChangeAbandoned for %s", change.id);
          }
        });
  }

  private void onChangeAbandonedImpl(ChangeInfo change, int revisionNumber, Account.Id accountId) {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(accountId)) {
      String revision =
          gApi.changes().id(change._number).revision(revisionNumber).commit(false).commit;
      logger.atFine().log("Detected revision %s abandoned on %s.", revision, change.project);
      abandonDownstream(change, revision, accountId);
    } catch (Exception e) {
      logger.atSevere().withCause(e).log(
          "Automerger plugin failed onChangeAbandoned for %s", change.id);
    }
  }

  /**
   * Updates downstream topics if a change has its topic modified.
   *
   * @param event Event we are listening to.
   */
  @Override
  public void onTopicEdited(TopicEditedListener.Event event) {
    ChangeInfo change = deepCopy(event.getChange());
    String oldTopic = event.getOldTopic();
    CurrentUser user = this.user.get();
    @SuppressWarnings("unused")
    Future<?> ignored = executorService.submit(() -> {
      try {
        onTopicEditedImpl(change, oldTopic, config.getContextUserId(user));
      } catch (ConfigInvalidException | UnsupportedOperationException e) {
        logger.atSevere().withCause(e).log(
            "Automerger plugin failed onTopicEdited for %s", change.id);
      }
    });
  }

  private void onTopicEditedImpl(ChangeInfo eventChange, String oldTopic, Account.Id accountId) {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(accountId)) {
      // We have to re-query for this in order to include the current revision
      ChangeInfo change;
      try {
        change =
            gApi.changes()
                .id(eventChange._number)
                .get(EnumSet.of(ListChangesOption.CURRENT_REVISION));
      } catch (RestApiException e) {
        logger.atSevere().withCause(e).log(
            "Automerger could not get change with current revision for onTopicEdited.");
        return;
      }
      String revision = change.currentRevision;
      Set<String> downstreamBranches;
      try {
        downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
      } catch (RestApiException | IOException | ConfigInvalidException e) {
        logger.atSevere().withCause(e).log("Failed to edit downstream topics of %s", change.id);
        return;
      }

      if (downstreamBranches.isEmpty()) {
        logger.atFine().log(
            "Downstream branches of %s on %s are empty", change.branch, change.project);
        return;
      }

      // If change is empty, prevent someone breaking topic by reapplying the old topic.
      if (isNullOrEmpty(change.topic)) {
        try {
          gApi.changes().id(change._number).topic(oldTopic);
          ReviewInput reviewInput = new ReviewInput();
          reviewInput.message(
              "Automerger prevented the topic from changing. Topic can only be modified on "
                  + "non-automerger-created CLs to a non-empty value.");
          reviewInput.notify = NotifyHandling.NONE;
          gApi.changes().id(change._number).revision(CURRENT).review(reviewInput);
        } catch (RestApiException e) {
          logger.atSevere().withCause(e).log(
              "Failed to prevent setting empty topic for automerger plugin.");
        }
      } else {
        for (String downstreamBranch : downstreamBranches) {
          try {
            List<Integer> existingDownstream =
                getExistingChangesOnBranch(revision, oldTopic, downstreamBranch, accountId);
            for (Integer changeNumber : existingDownstream) {
              logger.atFine().log("Setting topic %s on %s", change.topic, changeNumber);
              gApi.changes().id(changeNumber).topic(change.topic);
            }
          } catch (RestApiException | InvalidQueryParameterException e) {
            logger.atSevere().withCause(e).log("Failed to edit downstream topics of %s", change.id);
          }
        }
      }
    } catch (Exception e) {
      logger.atSevere().withCause(e).log(
          "Automerger plugin failed onTopicEdited for %s", eventChange.id);
    }
  }

  /**
   * Updates downstream votes for a change each time a comment is made.
   *
   * @param event Event we are listening to.
   */
  @Override
  public void onCommentAdded(CommentAddedListener.Event event) {
    if (!event.getRevision().isCurrent) {
      logger.atInfo().log(
          "Not updating downstream votes since revision %s is not current.",
          event.getRevision()._number);
      return;
    }

    ChangeInfo change = deepCopy(event.getChange());
    RevisionInfo eventRevision = deepCopy(event.getRevision());
    CurrentUser user = this.user.get();
    @SuppressWarnings("unused")
    Future<?> ignored = executorService.submit(() -> {
      try {
        onCommentAddedImpl(change, eventRevision, config.getContextUserId(user));
      } catch (ConfigInvalidException | UnsupportedOperationException e) {
        logger.atSevere().withCause(e).log(
            "Automerger plugin failed onCommentAdded for %s", change.id);
      }
    });
  }

  private void onCommentAddedImpl(ChangeInfo change, RevisionInfo eventRevision, Account.Id accountId) {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(accountId)) {
      String revision = gApi.changes().id(change._number).current().commit(false).commit;
      Set<String> downstreamBranches;
      downstreamBranches = config.getDownstreamBranches(change.branch, change.project);

      if (downstreamBranches.isEmpty()) {
        logger.atFine().log(
            "Downstream branches of %s on %s are empty", change.branch, change.project);
        return;
      }

      Map<String, LabelInfo> labels =
          gApi.changes()
              .id(change._number)
              .get(EnumSet.of(ListChangesOption.DETAILED_LABELS))
              .labels;

      for (String downstreamBranch : downstreamBranches) {
        try {
          List<Integer> existingDownstream =
              getExistingChangesOnBranch(revision, change.topic, downstreamBranch, accountId);
          for (Integer changeNumber : existingDownstream) {
            ChangeInfo downstreamChange =
                gApi.changes().id(changeNumber).get(EnumSet.of(ListChangesOption.CURRENT_REVISION));
            for (Map.Entry<String, LabelInfo> labelEntry : labels.entrySet()) {
              if (labelEntry.getValue().all != null && labelEntry.getValue().all.size() > 0) {
                OptionalInt maxVote =
                    labelEntry.getValue().all.stream()
                        .filter(o -> o.value != null)
                        .mapToInt(i -> i.value)
                        .max();

                if (maxVote.isPresent()) {
                  updateVote(downstreamChange, labelEntry.getKey(), (short) maxVote.getAsInt());
                }
              }
            }
          }
        } catch (RestApiException | InvalidQueryParameterException e) {
          logger.atSevere().withCause(e).log(
              "Exception when updating downstream votes of %s", change.id);
        }
      }
    } catch (Exception e) {
      logger.atSevere().withCause(e).log(
          "Automerger plugin failed onCommentAdded for %s", change.id);
    }
  }

  /**
   * Automerges changes downstream if a change is restored.
   *
   * @param event Event we are listening to.
   */
  @Override
  public void onChangeRestored(ChangeRestoredListener.Event event) {
    ChangeInfo change = deepCopy(event.getChange());
    RevisionInfo revision = deepCopy(event.getRevision());
    CurrentUser user = this.user.get();
    @SuppressWarnings("unused")
    Future<?> ignored = executorService.submit(() -> {
      try {
        onChangeRestoredImpl(change, revision, config.getContextUserId(user));
      } catch (ConfigInvalidException | UnsupportedOperationException e) {
        logger.atSevere().withCause(e).log(
            "Automerger plugin failed onChangeRestored for %s", change.id);
      }
    });
  }

  private void onChangeRestoredImpl(ChangeInfo change, RevisionInfo revision, Account.Id accountId) {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(accountId)) {
      automergeChanges(change, revision, accountId);
    } catch (Exception e) {
      logger.atSevere().withCause(e).log(
          "Automerger plugin failed onChangeRestored for %s", change.id);
    }
  }

  /**
   * Automerges changes downstream if a revision is created.
   *
   * @param event Event we are listening to.
   */
  @Override
  public void onRevisionCreated(RevisionCreatedListener.Event event) {
    ChangeInfo change = deepCopy(event.getChange());
    RevisionInfo revision = deepCopy(event.getRevision());
    CurrentUser user = this.user.get();

    @SuppressWarnings("unused")
    Future<?> ignored = executorService.submit(() -> {
      try {
        onRevisionCreatedImpl(change, revision, config.getContextUserId(user));
      } catch (ConfigInvalidException | UnsupportedOperationException e) {
        logger.atSevere().withCause(e).log(
            "Automerger plugin failed onRevisionCreated for %s", change.id);
      }
    });
  }

  public void onRevisionCreatedImpl(ChangeInfo change, RevisionInfo revision, Account.Id accountId) {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(accountId)) {
      automergeChanges(change, revision, accountId);
    } catch (Exception e){
      logger.atSevere().withCause(e).log(
          "Automerger plugin failed onRevisionCreated for %s", change.id);
    }
  }

  public String getOrSetTopic(int sourceId, String topic, Account.Id accountId)
      throws RestApiException {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(accountId)) {
      if (isNullOrEmpty(topic)) {
        topic = "am-" + UUID.randomUUID();
        logger.atFine().log("Setting original change %s topic to %s", sourceId, topic);
        gApi.changes().id(sourceId).topic(topic);
      }
      return topic;
    }
  }

  /**
   * Creates changes downstream, and votes on the automerge label if we have a failed merge.
   *
   * @param mdsChangeInput Input containing the downstream branch map and source change ID.
   * @param accountId Account ID to authorize Gerrit API calls.
   * @throws RestApiException Throws if we fail a REST API call.
   * @throws ConfigInvalidException Throws if we get a malformed configuration
   * @throws InvalidQueryParameterException Throws if we attempt to add an invalid value to query.
   * @throws StorageException Throws if we fail to open the request context
   */
  public void createChangesAndHandleConflicts(MultipleDownstreamChangeInput mdsChangeInput, Account.Id accountId)
      throws RestApiException, ConfigInvalidException, InvalidQueryParameterException,
          StorageException {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(accountId)) {
      ReviewInput reviewInput = new ReviewInput();
      Map<String, Short> labels = new HashMap<>();
      try {
        createDownstreamChanges(mdsChangeInput, accountId);

        reviewInput.message =
            "Automerging change "
                + mdsChangeInput.changeNumber
                + " to "
                + Joiner.on(", ").join(mdsChangeInput.dsBranchMap.keySet())
                + " succeeded!";
        reviewInput.notify = NotifyHandling.NONE;
      } catch (FailedMergeException e) {
        reviewInput.message = e.getDisplayString();
        reviewInput.notify = NotifyHandling.ALL;
        reviewInput.tag = MERGE_CONFLICT_TAG;
        // Vote minAutomergeVote if we hit a conflict.
        if (!config.minAutomergeVoteDisabled()) {
          labels.put(config.getAutomergeLabel(), config.getMinAutomergeVote());
        }
      }
      reviewInput.labels = labels;

      // Make the vote on the original change
      ChangeInfo originalChange =
          getOriginalChange(mdsChangeInput.changeNumber, mdsChangeInput.currentRevision);
      // if this fails, i.e. -2 is restricted, catch it and still post message without a vote.
      try {
        gApi.changes().id(originalChange._number).revision(CURRENT).review(reviewInput);
      } catch (AuthException e) {
        reviewInput.labels = null;
        gApi.changes().id(originalChange._number).revision(CURRENT).review(reviewInput);
      }
    }
  }

  @SuppressWarnings("unchecked")
  private <T> T deepCopy(T obj) {
    return (T) GSON.fromJson(GSON.toJson(obj), obj.getClass());
  }

  /**
   * Creates changes downstream.
   *
   * @param mdsChangeInput Input containing the downstream branch map and source change ID.
   * @param accountId Account ID to authorize Gerrit API calls.
   * @throws RestApiException Throws if we fail a REST API call.
   * @throws FailedMergeException Throws if we get a merge conflict when merging downstream.
   * @throws ConfigInvalidException Throws if we get a malformed config file
   * @throws InvalidQueryParameterException Throws if we attempt to add an invalid value to query.
   * @throws StorageException Throws if we fail to open the request context
   */
  private void createDownstreamChanges(MultipleDownstreamChangeInput mdsChangeInput, Account.Id accountId)
      throws RestApiException, FailedMergeException, ConfigInvalidException,
          InvalidQueryParameterException, StorageException {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(accountId)) {
      // Map from branch to error message
      Map<String, String> failedMergeBranchMap = new TreeMap<>();

      List<Integer> existingDownstream;
      for (String downstreamBranch : mdsChangeInput.dsBranchMap.keySet()) {
        // If there are existing downstream changes, update them
        // Otherwise, create them.
        boolean createDownstreams = true;
        if (mdsChangeInput.obsoleteRevision != null) {
          existingDownstream =
              getExistingChangesOnBranch(
                  mdsChangeInput.obsoleteRevision, mdsChangeInput.topic, downstreamBranch, accountId);
          if (!existingDownstream.isEmpty()) {
            logger.atFine().log(
                "Attempting to update downstream merge of %s on branch %s",
                mdsChangeInput.currentRevision, downstreamBranch);
            // existingDownstream should almost always be of length one, but
            // it's possible to construct it so that it's not
            for (Integer dsChangeNumber : existingDownstream) {
              try {
                UpdateDownstreamChangeInput updateDownstreamChangeInput = new UpdateDownstreamChangeInput();
                updateDownstreamChangeInput.upstreamRevision = mdsChangeInput.currentRevision;
                updateDownstreamChangeInput.upstreamSubject = mdsChangeInput.subject;
                updateDownstreamChangeInput.downstreamChangeNumber = dsChangeNumber;
                updateDownstreamChangeInput.doChange = mdsChangeInput.dsBranchMap.get(downstreamBranch);
                updateDownstreamChangeInput.upstreamChangeNumber = mdsChangeInput.changeNumber;
                updateDownstreamChangeInput.patchSetNumber = mdsChangeInput.patchsetNumber;
                updateDownstreamChangeInput.downstreamBranch = downstreamBranch;
                updateDownstreamChangeInput.topic = mdsChangeInput.topic;

                changeCreator.get().update(updateDownstreamChangeInput);
                createDownstreams = false;
              } catch (MergeConflictException | IntegrationConflictException e) {
                failedMergeBranchMap.put(downstreamBranch, e.getMessage());
                logger.atFine().log(
                    "Abandoning existing, obsolete %s due to merge conflict.", dsChangeNumber);
                abandonChange(dsChangeNumber);
              }
            }
          }
        }
        if (createDownstreams) {
          logger.atFine().log(
              "Attempting to create downstream change of %s on branch %s",
              mdsChangeInput.currentRevision, downstreamBranch);
          SingleDownstreamChangeInput sdsChangeInput = new SingleDownstreamChangeInput();
          sdsChangeInput.currentRevision = mdsChangeInput.currentRevision;
          sdsChangeInput.changeNumber = mdsChangeInput.changeNumber;
          sdsChangeInput.patchsetNumber = mdsChangeInput.patchsetNumber;
          sdsChangeInput.project = mdsChangeInput.project;
          sdsChangeInput.topic = mdsChangeInput.topic;
          sdsChangeInput.subject = mdsChangeInput.subject;
          sdsChangeInput.downstreamBranch = downstreamBranch;
          sdsChangeInput.doChange = mdsChangeInput.dsBranchMap.get(downstreamBranch);
          try {
            createSingleDownstreamChange(sdsChangeInput, accountId);
          } catch (MergeConflictException | IntegrationConflictException e) {
            failedMergeBranchMap.put(downstreamBranch, e.getMessage());
          }
        }
      }

      if (!failedMergeBranchMap.isEmpty()) {
        String conflictMessage = config.getConflictMessage();
        if (mdsChangeInput.project.equals(config.getManifestProject())) {
          conflictMessage = config.getManifestConflictMessage();
        }
        throw new FailedMergeException(
            failedMergeBranchMap,
            mdsChangeInput.currentRevision,
            config.getHostName(),
            mdsChangeInput.project,
            mdsChangeInput.changeNumber,
            mdsChangeInput.patchsetNumber,
            conflictMessage,
            mdsChangeInput.topic);
      }
    }
  }

  /**
   * Get change numbers of the immediately downstream changes of the revision on the branch.
   *
   * @param topic Topic of the original change.
   * @param downstreamBranch Branch to check for existing automerger CLs.
   * @param accountId Account ID to authorize Gerrit API calls.
   * @return List of change numbers that are downstream of the given branch.
   * @throws RestApiException Throws when we fail a REST API call.
   * @throws InvalidQueryParameterException Throws when we try to add an invalid value to the query.
   * @throws ConfigInvalidException Throws if we fail to read the config
   * @throws StorageException Throws if we fail to open the request context
   */
  private List<Integer> getExistingChangesOnBranch(
      String upstreamRevision, String topic, String downstreamBranch, Account.Id accountId)
      throws RestApiException, InvalidQueryParameterException, StorageException,
          ConfigInvalidException {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(accountId)) {
      List<Integer> downstreamChangeNumbers = new ArrayList<>();
      List<ChangeInfo> changes = ChangeUtils.getChangesInTopicAndBranch(gApi, topic, downstreamBranch);

      ChangeMode changeMode = config.changeMode();
      for (ChangeInfo change : changes) {
        if(ChangeUtils.isDownstreamChange(gApi, upstreamRevision, change, changeMode)) {
          downstreamChangeNumbers.add(change._number);
        }
      }

      return downstreamChangeNumbers;
    }
  }

  /**
   * Create a single downstream merge.
   *
   * @param sdsChangeInput Input containing metadata for the merge.
   * @param accountId Account ID to authorize Gerrit API calls.
   * @throws RestApiException
   * @throws ConfigInvalidException
   * @throws InvalidQueryParameterException
   * @throws StorageException
   */
  private void createSingleDownstreamChange(SingleDownstreamChangeInput sdsChangeInput, Account.Id accountId)
      throws RestApiException, ConfigInvalidException, InvalidQueryParameterException,
          StorageException {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(accountId)) {
      String currentTopic = getOrSetTopic(sdsChangeInput.changeNumber, sdsChangeInput.topic, accountId);

      ChangeApi downstreamChange = changeCreator.get().create(sdsChangeInput, currentTopic);
      if(downstreamChange != null) {
        ChangeUtils.tagChange(gApi, downstreamChange.get(), "Automerger change created!");
      }
    }
  }

  private void automergeChanges(ChangeInfo change, RevisionInfo revisionInfo, Account.Id accountId)
      throws RestApiException, IOException, ConfigInvalidException, InvalidQueryParameterException,
          StorageException {
    String currentRevision =
        gApi.changes().id(change._number).revision(revisionInfo._number).commit(false).commit;
    logger.atFine().log(
        "Handling patchsetevent with change id %s and revision %s", change.id, currentRevision);

    Set<String> downstreamBranches = config.getDownstreamBranches(change.branch, change.project);

    if (downstreamBranches.isEmpty()) {
      logger.atFine().log(
          "Downstream branches of %s on %s are empty", change.branch, change.project);
      return;
    }

    // Map whether or not we should merge it or skip it for each downstream
    Map<String, Boolean> dsBranchMap = new HashMap<>();
    for (String downstreamBranch : downstreamBranches) {
      boolean isSkipMerge = config.isSkipMerge(change.branch, downstreamBranch, change.subject);
      dsBranchMap.put(downstreamBranch, !isSkipMerge);
    }
    logger.atFine().log("Automerging change %s from branch %s", change.id, change.branch);

    ChangeApi currentChange = gApi.changes().id(change._number);
    String previousRevision = getPreviousRevision(currentChange, revisionInfo._number);

    MultipleDownstreamChangeInput mdsMergeInput = new MultipleDownstreamChangeInput();
    mdsMergeInput.dsBranchMap = dsBranchMap;
    mdsMergeInput.changeNumber = change._number;
    mdsMergeInput.patchsetNumber = revisionInfo._number;
    mdsMergeInput.project = change.project;
    mdsMergeInput.topic = getOrSetTopic(change._number, change.topic, accountId);
    mdsMergeInput.subject = change.subject;
    mdsMergeInput.obsoleteRevision = previousRevision;
    mdsMergeInput.currentRevision = currentRevision;

    createChangesAndHandleConflicts(mdsMergeInput, accountId);
  }

  private void abandonDownstream(ChangeInfo change, String revision, Account.Id accountId)
      throws ConfigInvalidException, StorageException {
    try {
      Set<String> downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
      if (downstreamBranches.isEmpty()) {
        logger.atFine().log(
            "Downstream branches of %s on %s are empty", change.branch, change.project);
        return;
      }

      for (String downstreamBranch : downstreamBranches) {
        List<Integer> existingDownstream =
            getExistingChangesOnBranch(revision, change.topic, downstreamBranch, accountId);
        logger.atFine().log("Abandoning existing downstreams: %s", existingDownstream);
        for (Integer changeNumber : existingDownstream) {
          abandonChange(changeNumber);
        }
      }
    } catch (RestApiException | IOException | InvalidQueryParameterException e) {
      logger.atSevere().withCause(e).log("Failed to abandon downstreams of %s", change.id);
    }
  }

  private void updateVote(ChangeInfo change, String label, short vote) throws RestApiException {
    logger.atFine().log("Giving %s for label %s to %s", vote, label, change.id);
    // Vote on all downstream branches unless merge conflict.
    ReviewInput reviewInput = new ReviewInput();
    Map<String, Short> labels = new HashMap<>();
    labels.put(label, vote);
    reviewInput.labels = labels;
    reviewInput.notify = NotifyHandling.NONE;
    reviewInput.tag = ChangeUtils.AUTOMERGER_TAG;
    try {
      gApi.changes().id(change.id).revision(CURRENT).review(reviewInput);
    } catch (AuthException e) {
      logger.atSevere().withCause(e).log("Automerger could not set label, but still continuing.");
    }
  }

  private String getPreviousRevision(ChangeApi change, int currentPatchSetNumber)
      throws RestApiException {
    String previousRevision = null;
    int maxPatchSetNum = 0;
    if (currentPatchSetNumber > 1) {
      // Get sha of patch set with highest number we can see
      Map<String, RevisionInfo> revisionMap =
          change.get(EnumSet.of(ListChangesOption.ALL_REVISIONS)).revisions;
      for (Map.Entry<String, RevisionInfo> revisionEntry : revisionMap.entrySet()) {
        int revisionPatchNumber = revisionEntry.getValue()._number;
        if (revisionPatchNumber > maxPatchSetNum && revisionPatchNumber < currentPatchSetNumber) {
          previousRevision = revisionEntry.getKey();
          maxPatchSetNum = revisionPatchNumber;
        }
      }
    }
    return previousRevision;
  }

  private ChangeInfo getOriginalChangeCherryPickMode(int changeNumber)
      throws RestApiException, InvalidQueryParameterException {

    ChangeInfo current = gApi.changes().id(changeNumber).get();
    String topic = current.topic;
    List<ChangeInfo> changesInTopic = getChangesInTopic(topic);
    for (ChangeInfo change : changesInTopic) {
      if(ChangeUtils.isDownstreamCherryPick(gApi, change.currentRevision, current)){
        return getOriginalChangeCherryPickMode(change._number);
      }
    }

    return current;
  }

  private ChangeInfo getOriginalChangeMergeMode(int changeNumber, String currentRevision)
      throws RestApiException, InvalidQueryParameterException {
    List<String> parents = ChangeUtils.getChangeParents(gApi, changeNumber, currentRevision);
    if (parents.size() >= 2) {
      String secondParentRevision = parents.get(1);
      String topic = gApi.changes().id(changeNumber).topic();
      List<ChangeInfo> changesInTopic = getChangesInTopic(topic);
      for (ChangeInfo change : changesInTopic) {
        if (change.currentRevision.equals(secondParentRevision)) {
          return getOriginalChange(change._number, secondParentRevision);
        }
      }
    }
    return gApi.changes().id(changeNumber).get();
  }

  private ChangeInfo getOriginalChange(int changeNumber, String currentRevision)
      throws RestApiException, InvalidQueryParameterException {
    ChangeMode changeMode = ChangeMode.MERGE;
    try {
      changeMode = config.changeMode();
    } catch (ConfigInvalidException e) {
      logger.atSevere().withCause(e).log("Automerger could not read config, but still continuing.");
    }

    if(changeMode == ChangeMode.CHERRY_PICK){
      return getOriginalChangeCherryPickMode(changeNumber);
    } else {
      return getOriginalChangeMergeMode(changeNumber, currentRevision);
    }
  }

  private void abandonChange(Integer changeNumber) throws RestApiException {
    logger.atFine().log("Abandoning change: %s", changeNumber);
    AbandonInput abandonInput = new AbandonInput();
    abandonInput.notify = NotifyHandling.NONE;
    abandonInput.message = "Upstream change updated; abandoning due to upstream conflict.";
    gApi.changes().id(changeNumber).abandon(abandonInput);
  }

  private List<ChangeInfo> getChangesInTopic(String topic)
      throws InvalidQueryParameterException, RestApiException {
    QueryBuilder queryBuilder = ChangeUtils.constructTopicQuery(topic);
    return gApi.changes()
        .query(queryBuilder.get())
        .withOptions(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_COMMIT)
        .get();
  }
}
